# Feature development workflow

**STATUS**: Phase 1 UPDATED ✅ | Architecture Revised ✅ | New Requirements Defined ✅

---

## UPDATED REQUIREMENTS (USER REQUEST)

✅ **No User Authentication**: Customers shop anonymously
✅ **Session-Based Cart**: Each visitor has unique session ID
✅ **Concurrent Users**: Supports 1, 100, 100,000+ simultaneous shoppers (zero interference)
✅ **WhatsApp Notification**: Owner receives WhatsApp on "Iniciar Compra" with order details
✅ **Enhanced Product Catalog**: Name, Categoría, SubCategoría, Descripción, Precio Venta, Imagen URL
✅ **Admin Product Management**: Add, edit, delete, visibility toggle, stock toggle
✅ **Responsive**: Mobile, tablet, desktop

---

## Workflow Steps

### [x] Step: Requirements

Your job is to generate a Product Requirements Document based on the feature description,

First, analyze the provided feature definition and determine unclear aspects. For unclear aspects: - Make informed guesses based on context and industry standards - Only mark with [NEEDS CLARIFICATION: specific question] if: - The choice significantly impacts feature scope or user experience - Multiple reasonable interpretations exist with different implications - No reasonable default exists - Prioritize clarifications by impact: scope > security/privacy > user experience > technical details

Ask up to 5 most priority clarifications to the user. Then, create the document following this template:

```
# Feature Specification: [FEATURE NAME]


## User Stories*


### User Story 1 - [Brief Title]

**Acceptance Scenarios**:

1. **Given** [initial state], **When** [action], **Then** [expected outcome]
2. **Given** [initial state], **When** [action], **Then** [expected outcome]

---

## Requirements*

## Success Criteria*

```

Save the PRD into `c:\Users\54225\Desktop\EcommercePocopan\.zencoder\chats\ac38ada5-4f27-49ae-9950-8e28515fa7d2/requirements.md`.

### [x] Step: Technical Specification

Based on the PRD in `c:\Users\54225\Desktop\EcommercePocopan\.zencoder\chats\ac38ada5-4f27-49ae-9950-8e28515fa7d2/requirements.md`, create a detailed technical specification to be used by a coding agent to implement the feature. Follow this template:

```
# Technical Specification: [FEATURE]

## Technical Context
Language/Version, primary dependencies, etc

## Technical Implementation Brief

Summarize key technical decisions for implementing the feature. Make sure they take into account the existing code as much as possible.

## Source Code Structure

## Contracts

Define addition or changes in data models, DB schemas, APIs, code interfaces etc

## Delivery Phases

Define several incremental deliverables for the feature. Each should be a minimal viable product testable end-to-end.

## Verification Strategy

Define how the coding agent can verify each deliverable it creates. Provide instructions for the agent to perform the verification using available tools (lint/test commands, bash commands) and create helper scripts and tools for more complex result verification.
The verification for each deliverable should be executable by a coding agent using built-in capabilities (lint and test commands from the project, bash commands), pre-generated helper scripts or MCP servers. Research and add to the spec:

- MCP servers that should be installed to help the agent with the verification

- helper scripts that need to be generated in the first phases of the plan to verify complex scenarios that can't be covered by the tests in the project's test framework(s)

- any sample input artifact(s) that are required for verification. Note if these artifacts can be a) generated by the agent; b) discovered by the agent on line; c) must be provided by the user.
```

Save the spec to `c:\Users\54225\Desktop\EcommercePocopan\.zencoder\chats\ac38ada5-4f27-49ae-9950-8e28515fa7d2/spec.md`.

### [x] Step: Implementation Plan

Based on the technical spec in `c:\Users\54225\Desktop\EcommercePocopan\.zencoder\chats\ac38ada5-4f27-49ae-9950-8e28515fa7d2/spec.md`, the implementation will follow 5 phases.

---

## Phase 1: Product Catalog & Basic UI (MVP Core)

### [x] Step 1.1: Project Setup & Database Schema
**Objective**: Initialize Next.js project with Supabase, TypeScript, and Tailwind CSS. Create database schema for products.

**Contracts Used**: Products table (from spec.md)

**Task Instructions**:
1. Check if project exists in `c:\Users\54225\Desktop\EcommercePocopan`. If not, create new Next.js 14+ project with `npx create-next-app@latest`
2. Install dependencies: `@supabase/supabase-js`, `@types/node`, Tailwind CSS
3. Create `.env.local` with Supabase credentials (NEXT_PUBLIC_SUPABASE_URL, NEXT_PUBLIC_SUPABASE_ANON_KEY, SUPABASE_SERVICE_ROLE_KEY)
4. Create `lib/supabase.ts` client initialization
5. Create `supabase/migrations/00_initial_schema.sql` with products, users, cart_items, orders, order_items, addresses tables
6. Run migrations in Supabase dashboard to create schema
7. Create `supabase/seed.sql` with 20+ sample products (toys, educational products)
8. Load seed data into Supabase

**Deliverable**: Working Next.js app connected to Supabase with product data in database

**Verification**: 
- Run `npm run build` — no errors
- Run `npm run lint` (or `npm run typecheck` if available)
- Verify Supabase tables exist with correct schema
- Verify sample products in Supabase dashboard

---

### [x] Step 1.2: Homepage & Product Listing Page
**Objective**: Build homepage with featured products and product listing page with filtering.

**Contracts Used**: GET /api/products (from spec.md)

**Task Instructions**:
1. Create `app/page.tsx` (homepage) with:
   - Hero section with brand intro
   - Featured products grid (top 6 products)
   - Search bar (optional for MVP)
   - Newsletter signup (optional)
2. Create `app/products/page.tsx` (listing) with:
   - Product grid layout (responsive: 1 col mobile, 2 tablet, 3+ desktop)
   - Category filter sidebar
   - Price range filter (optional)
3. Create `components/ProductCard.tsx` (reusable product card with image, name, price, stock status)
4. Create `components/ProductFilter.tsx` (category filter with checkboxes)
5. Create `api/products/route.ts` to fetch all products from Supabase with optional category filter
6. Style with Tailwind CSS (use utility classes, no custom CSS)

**Deliverable**: Homepage and product listing pages with working filters

**Verification**:
- Visit `http://localhost:3000` → products display
- Click category filter → products update (filter works)
- Check responsive layout on mobile (use DevTools)
- No TypeScript errors or console errors

---

### [x] Step 1.3: Product Detail Page
**Objective**: Build product detail page with full information and "Add to Cart" button.

**Contracts Used**: GET /api/products/[id] (from spec.md)

**Task Instructions**:
1. Create `app/products/[id]/page.tsx` with:
   - Product image (large)
   - Product name, description, price
   - Stock availability badge
   - Age group tag
   - "Add to Cart" button (functionality in Phase 2)
   - Related products section (optional)
2. Create `api/products/[id]/route.ts` to fetch single product by ID
3. Handle 404 if product not found
4. Add breadcrumb navigation (Home > Products > [Product Name])

**Deliverable**: Product detail page fully functional

**Verification**:
- Click on product from listing → detail page loads
- Product data displays correctly (from database)
- URL is `/products/[product-id]`
- Responsive layout on mobile
- 404 page when accessing invalid product ID

---

### [x] Step 1.4: Navbar, Footer & Responsive Layout
**Objective**: Build reusable navbar and footer components. Ensure responsive design across all pages.

**Task Instructions**:
1. Create `components/Navbar.tsx` with:
   - Logo/brand name
   - Navigation links (Home, Products, Cart, Account)
   - Mobile hamburger menu (Tailwind responsive)
   - Cart count badge (connected to cart state in Phase 2)
2. Create `components/Footer.tsx` with:
   - Links (About, Contact, Terms, Privacy)
   - Email subscription form
   - Social links
   - Copyright notice
3. Create `app/layout.tsx` (root layout) with Navbar and Footer on all pages
4. Add Tailwind responsive utilities (md:, lg:, xl: breakpoints)
5. Test on mobile (375px), tablet (768px), desktop (1920px)

**Deliverable**: Consistent navbar/footer across all pages, fully responsive

**Verification**:
- Navbar appears on all pages
- Hamburger menu works on mobile
- Desktop navigation visible on large screens
- No layout shifts
- Footer visible on all pages
- Mobile-first responsive design

---

### [x] Step 1.5: Build Success (Ready for Deployment)
**Objective**: Deploy Phase 1 to Vercel for live testing.

**Task Instructions**:
1. Push code to GitHub repository
2. Connect GitHub repo to Vercel (via vercel.com dashboard)
3. Set environment variables in Vercel project settings (NEXT_PUBLIC_SUPABASE_URL, etc.)
4. Deploy and verify live URL
5. Test all pages on live Vercel URL

**Deliverable**: Live e-commerce site on Vercel with Phase 1 features

**Verification**:
- Visit Vercel deployment URL → homepage loads
- Products display correctly
- Filters work
- Product details load
- No console errors in production

---

## Phase 2: Shopping Cart & User Accounts

### [ ] Step 2.1: Cart State Management & UI
**Objective**: Implement cart state using React Context, localStorage persistence, and cart page.

**Task Instructions**:
1. Create `hooks/useCart.ts` custom hook with Context API for cart state management
2. Create `context/CartContext.tsx` with:
   - Add to cart function
   - Remove from cart function
   - Update quantity function
   - Clear cart function
3. Implement localStorage persistence (save cart on change, load on mount)
4. Update `components/ProductCard.tsx` "Add to Cart" button to dispatch cart action
5. Create `app/cart/page.tsx` with:
   - Cart items list (product image, name, quantity, price)
   - Update quantity controls (+ / - buttons)
   - Remove item button
   - Cart subtotal, tax (optional), total
   - "Proceed to Checkout" button (routes to Phase 3)
6. Update Navbar to show cart count badge

**Deliverable**: Fully functional shopping cart with persistence

**Verification**:
- Add item to cart from product detail → item appears in cart
- Update quantity in cart → total updates
- Refresh page → cart persists (localStorage)
- Remove item → cart updates
- Cart count badge in navbar updates
- Proceed to Checkout button visible

---

### [ ] Step 2.2: User Authentication (Signup/Login)
**Objective**: Implement email/password authentication using Supabase Auth.

**Task Instructions**:
1. Create `lib/auth.ts` with auth helper functions (signup, login, logout, getCurrentUser)
2. Create `hooks/useAuth.ts` custom hook to access auth state globally
3. Create `context/AuthContext.tsx` to provide auth state to entire app
4. Create `app/auth/signup/page.tsx` with:
   - Email input
   - Password input
   - Confirm password input
   - Submit button
   - Link to login
   - Form validation (email format, password length)
5. Create `app/auth/login/page.tsx` with:
   - Email input
   - Password input
   - "Remember me" checkbox (optional)
   - Submit button
   - Link to signup
   - Error message display
6. Create `app/auth/logout/route.ts` to handle logout (clears session)
7. Add "Sign Up / Login" link to Navbar (hidden if user logged in)
8. Create profile menu in Navbar for logged-in users

**Deliverable**: Full authentication flow with signup/login/logout

**Verification**:
- Signup with new email → account created in Supabase
- Login with valid credentials → redirected to account page
- Invalid credentials → error message shown
- Logout → redirected to home, session cleared
- Navbar shows user info when logged in

---

### [ ] Step 2.3: User Account Dashboard & Profile
**Objective**: Build user dashboard with profile info and order history.

**Task Instructions**:
1. Create `app/account/page.tsx` (protected route) with:
   - User profile section (name, email, phone - editable)
   - Saved addresses section
   - Saved payment methods (optional for Phase 2)
   - Recent orders preview
2. Create `app/account/orders/[id]/page.tsx` to show order detail:
   - Order ID, status, date
   - Items list (product name, quantity, price)
   - Shipping address
   - Tracking number (if shipped)
   - Total amount
3. Create `api/orders/route.ts` to fetch user's orders from database
4. Create `api/orders/[id]/route.ts` to fetch single order
5. Add middleware or page guard to redirect non-logged-in users to login

**Deliverable**: User account dashboard with order history

**Verification**:
- Login user → can access /account
- Non-logged-in user → redirected to /auth/login
- Order history displays correctly
- Click order → detail page loads with full info
- Edit profile → changes save to Supabase

---

### [ ] Step 2.4: Protection & Error Handling
**Objective**: Add route protection, error boundaries, and loading states.

**Task Instructions**:
1. Create middleware in `lib/middleware.ts` to protect admin/account routes (optional, can use client-side guards for MVP)
2. Create `components/ErrorBoundary.tsx` to catch React errors
3. Add error pages (`app/error.tsx`, `app/not-found.tsx`)
4. Add loading skeletons for product listing and account page
5. Add toast/notification system for user feedback (optional: use `react-hot-toast`)

**Deliverable**: Robust error handling and user feedback

**Verification**:
- Accessing `/account` without login → redirected to login
- Broken route → shows 404 page
- Loading state visible while fetching data
- Logout → cleared from account page

---

## Phase 3: Checkout & Payment Integration

### [ ] Step 3.1: Stripe Setup & Payment Infrastructure
**Objective**: Integrate Stripe for payment processing.

**Task Instructions**:
1. Create Stripe account (stripe.com) and get API keys (test mode)
2. Add to `.env.local`: NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY, STRIPE_SECRET_KEY
3. Install `@stripe/stripe-js` and `stripe` npm packages
4. Create `lib/stripe.ts` to initialize Stripe client and server
5. Create `api/payments/stripe/route.ts` to create Stripe checkout session
6. Create `api/payments/stripe/webhook/route.ts` to handle Stripe webhooks (payment confirmation)
7. Configure webhook endpoint in Stripe dashboard to point to `/api/payments/stripe/webhook`

**Deliverable**: Stripe integration ready for payments

**Verification**:
- Run `npm run build` — no errors
- Stripe keys in env vars
- Webhook endpoint registered in Stripe dashboard
- Test payment with card `4242 4242 4242 4242` succeeds

---

### [ ] Step 3.2: Multi-Step Checkout Form
**Objective**: Build checkout flow with shipping address, method selection, and payment method choice.

**Task Instructions**:
1. Create `app/checkout/page.tsx` with multi-step form:
   - Step 1: Shipping Address (street, city, state, postal code)
   - Step 2: Shipping Method (Mercado Libre / Local Pickup)
   - Step 3: Payment Method (Stripe / Local Payment)
   - Step 4: Review & Confirm
2. Create `components/CheckoutForm.tsx` with form state management
3. Create `components/ShippingSelector.tsx` to show shipping options with costs
4. Create `components/PaymentSelector.tsx` to show payment options
5. Add form validation (required fields, email format, etc.)
6. Use Zod (or React Hook Form) for schema validation

**Deliverable**: Complete checkout flow form

**Verification**:
- Fill checkout form → all steps complete without errors
- Form validation works (missing required fields show errors)
- Shipping method selection shows different costs
- Review page shows order summary

---

### [ ] Step 3.3: Shipping Integration (Mercado Libre API)
**Objective**: Calculate shipping costs using Mercado Libre API.

**Task Instructions**:
1. Create Mercado Libre seller account and get API credentials
2. Add to `.env.local`: MERCADOLIBRE_ACCESS_TOKEN, MERCADOLIBRE_SELLER_ID
3. Create `lib/mercadolibre.ts` API wrapper for ML endpoints
4. Create `api/shipping/mercadolibre/route.ts` to calculate shipping costs
5. In checkout form, when user selects "Mercado Libre" shipping:
   - Call `/api/shipping/mercadolibre` with zip code
   - Display calculated cost
   - Store shipping info in checkout state

**Deliverable**: Shipping cost calculation working

**Verification**:
- Select Mercado Libre shipping in checkout
- Enter zip code → shipping cost calculates and displays
- Cost is reasonable (matches ML pricing)

---

### [ ] Step 3.4: Order Creation & Database Storage
**Objective**: Create orders in database upon checkout confirmation.

**Task Instructions**:
1. Create `api/checkout/route.ts` to:
   - Validate cart items (stock available)
   - Calculate totals (products + shipping)
   - Create order record in database (orders table)
   - Create order_items records for each product
   - Decrement product stock_quantity
   - Return order ID
2. In checkout form submit:
   - Call `/api/checkout` to create order
   - If successful, proceed to payment
   - If error, show error message
3. Add database transaction-like behavior (if order creation fails, no payment attempt)

**Deliverable**: Orders created and stored in Supabase

**Verification**:
- Complete checkout → order appears in Supabase orders table
- Order items correctly stored in order_items table
- Product stock decremented
- Order status is "pending" initially

---

### [ ] Step 3.5: Stripe Payment Processing
**Objective**: Process payments through Stripe and update order status.

**Task Instructions**:
1. In checkout success (Step 4), display Stripe payment form
2. Use `@stripe/react-stripe-js` to embed payment form
3. On form submit:
   - Call `/api/payments/stripe` with order ID
   - Get client secret from response
   - Submit payment via Stripe
4. On payment success:
   - Webhook updates order status to "confirmed"
   - Decrement stock (already done, but verify no double-decrement)
   - Send confirmation email
5. On payment failure:
   - Show error message
   - Keep order in "pending" status
   - Allow user to retry

**Deliverable**: Payments processed through Stripe, orders confirmed

**Verification**:
- Test card `4242 4242 4242 4242` → payment succeeds
- Order status updates to "confirmed" in database
- Test invalid card → payment fails with error
- Stock not double-decremented

---

### [ ] Step 3.6: Order Confirmation & Email Notifications
**Objective**: Show confirmation page and send order confirmation emails.

**Task Instructions**:
1. Create `app/checkout/success/page.tsx` with:
   - Order confirmation message
   - Order ID and date
   - Order summary (items, total, shipping)
   - Expected delivery/pickup date
   - Link to order details page
2. Create `app/checkout/cancel/page.tsx` for failed payments
3. Setup email service (use Resend or Supabase Edge Functions)
4. Create email template for order confirmation
5. Trigger email on webhook (when order status → "confirmed")
6. Email should include order details and tracking/pickup info

**Deliverable**: Confirmation page and automated emails

**Verification**:
- Complete payment → success page shows
- Check email inbox → order confirmation received
- Email contains order ID and summary
- Cancel payment → cancel page shows

---

## Phase 4: Admin Dashboard & Fulfillment

### [ ] Step 4.1: Admin Authentication & Route Protection
**Objective**: Implement admin role and protect admin routes.

**Task Instructions**:
1. Update `profiles` table to include `is_admin` boolean field
2. Update signup/login to check `is_admin` status
3. Create admin user manually in Supabase (set is_admin=true for test user)
4. Create middleware or auth guard to check admin status
5. Protect all `/admin/*` routes with role check
6. Redirect non-admins to home page

**Deliverable**: Admin role system working

**Verification**:
- Admin user can access `/admin/dashboard`
- Non-admin user redirected from admin routes
- Navbar shows admin link only for admin users

---

### [ ] Step 4.2: Admin Dashboard Overview
**Objective**: Build admin dashboard with stats and navigation.

**Task Instructions**:
1. Create `app/admin/layout.tsx` with admin-specific layout
2. Create `app/admin/dashboard/page.tsx` with:
   - Key metrics (total orders, total revenue, pending orders, inventory count)
   - Recent orders list (last 10)
   - Navigation to products and orders management
3. Add dashboard cards showing stats
4. Style with Tailwind (clean, professional admin UI)

**Deliverable**: Admin dashboard with stats

**Verification**:
- Admin can access dashboard
- Stats display correctly (query database)
- Recent orders show correct data
- Navigation links work

---

### [ ] Step 4.3: Product Management (CRUD)
**Objective**: Build product management interface for admins.

**Task Instructions**:
1. Create `app/admin/products/page.tsx` with:
   - Table/list of all products
   - Edit & delete buttons
   - Add new product button
   - Search/filter products
2. Create `app/admin/products/new/page.tsx` to add product:
   - Form with product fields (name, description, price, stock, category, image)
   - Image upload to Supabase Storage
   - Submit saves to database
3. Create `app/admin/products/[id]/edit/page.tsx` to edit product:
   - Prefill form with product data
   - Allow editing all fields
   - Update in database
4. Create `api/admin/products/route.ts` (POST for add, GET for list)
5. Create `api/products/[id]/route.ts` (PATCH for edit, DELETE for delete)
6. Protect all admin product endpoints with admin role check

**Deliverable**: Full product CRUD for admins

**Verification**:
- Admin can view all products
- Add new product → appears in list
- Edit product → changes saved
- Delete product → removed from list
- Stock levels update correctly
- Non-admin cannot access

---

### [ ] Step 4.4: Order Management & Status Updates
**Objective**: Build order management interface for processing and fulfillment.

**Task Instructions**:
1. Create `app/admin/orders/page.tsx` with:
   - Table of all orders (ID, customer, status, total, date)
   - Filter by status (pending, confirmed, shipped, delivered)
   - Search by order ID or customer email
   - Click to view detail
2. Create `app/admin/orders/[id]/page.tsx` with:
   - Full order detail (items, customer, addresses, payment method)
   - Status update dropdown (pending → confirmed → shipped → delivered)
   - Shipping tracking number input (for ML shipments)
   - "Generate Label" button (for ML shipments)
   - "Mark as Ready" button (for pickup orders)
   - Notes field for internal comments
3. Create `api/admin/orders/[id]/route.ts` to update order status
4. Protect endpoint with admin role check

**Deliverable**: Order management interface

**Verification**:
- Admin can view all orders
- Filter by status works
- Update order status → saves to database
- Tracking number input works
- Only admins can update orders

---

### [ ] Step 4.5: Mercado Libre Shipment Creation
**Objective**: Create shipping labels and integrate with Mercado Libre fulfillment.

**Task Instructions**:
1. Create `api/shipping/mercadolibre/create/route.ts` to create shipment in ML:
   - Call ML API to create shipment for order
   - Pass order items, customer address, seller address
   - Return shipment ID and label URL
2. In admin order detail page:
   - When order status → "shipped"
   - Show option to "Generate ML Label"
   - Call create shipment API
   - Store shipment ID in order record
   - Display generated label link (PDF)
   - Show tracking number returned by ML
3. Implement label download/print option

**Deliverable**: Mercado Libre label generation working

**Verification**:
- Admin marks order as "shipped"
- Click "Generate Label" → creates shipment in ML
- Tracking number appears in order
- Label PDF can be downloaded/printed

---

### [ ] Step 4.6: Pickup Orders Management
**Objective**: Handle local pickup orders.

**Task Instructions**:
1. Add pickup location field to orders table (if not exists)
2. In admin order detail:
   - If shipping method = "pickup", show "Mark as Ready for Pickup" button
   - Clicking button sends email notification to customer
   - Update order status to "ready_for_pickup"
3. Create email template for pickup ready notification
4. Customer receives email with pickup location and order ID

**Deliverable**: Pickup order fulfillment flow

**Verification**:
- Create order with pickup shipping method
- Admin marks as ready → email sent
- Customer receives pickup notification with location

---

## Phase 5: Testing, Polish & Optimization

### [ ] Step 5.1: E2E Testing (Playwright)
**Objective**: Write comprehensive E2E tests for critical user flows.

**Task Instructions**:
1. Install Playwright: `npm install -D @playwright/test`
2. Create `playwright.config.ts` with test configuration
3. Write E2E tests in `tests/e2e/` directory:
   - Homepage loads
   - Browse products & filter
   - View product detail
   - Add to cart & update quantity
   - Signup & login flows
   - Checkout flow (mock payment)
   - Admin product CRUD
   - Admin order management
4. Run tests: `npx playwright test`
5. Generate HTML report: `npx playwright show-report`

**Deliverable**: E2E tests covering critical flows

**Verification**:
- All tests pass
- Coverage includes happy paths and basic error cases
- No flaky tests

---

### [ ] Step 5.2: Error Handling & Edge Cases
**Objective**: Handle edge cases and improve error messages.

**Task Instructions**:
1. Test and fix:
   - Out of stock products (show unavailable, disable add to cart)
   - Expired sessions (redirect to login)
   - Network errors (show retry option)
   - Form validation errors (show user-friendly messages)
   - Payment failures (clear messaging)
2. Add error logging (optional: Sentry)
3. Improve error page designs

**Deliverable**: Robust error handling throughout app

**Verification**:
- Out of stock products disabled
- Network errors handled gracefully
- Form errors clear and helpful
- No unhandled JavaScript errors

---

### [ ] Step 5.3: Performance Optimization
**Objective**: Optimize image loading, build size, and runtime performance.

**Task Instructions**:
1. Replace all `<img>` tags with Next.js `<Image>` component
2. Optimize images (compress, use WebP format)
3. Lazy load images (loading="lazy")
4. Use `next/dynamic` for heavy components (optional)
5. Check bundle size: `npm run analyze` or `npm run build` report
6. Verify Web Vitals (LCP, FID, CLS)
7. Use Chrome DevTools Lighthouse for audit

**Deliverable**: Performance optimized app

**Verification**:
- Lighthouse score > 80 on mobile and desktop
- Images load quickly
- No layout shift (CLS < 0.1)
- Bundle size reasonable

---

### [ ] Step 5.4: Security Audit
**Objective**: Verify security best practices.

**Task Instructions**:
1. Check all API routes validate input (use Zod or similar)
2. Verify database RLS policies enforce admin-only access
3. Ensure environment variables not exposed client-side
4. Check CORS headers correct
5. Verify HTTPS enforced (Vercel default)
6. Check for XSS vulnerabilities (Next.js sanitizes by default)
7. Verify CSRF protection (if applicable)

**Deliverable**: Security verified

**Verification**:
- All endpoints validate input
- RLS policies prevent unauthorized access
- No secrets in client-side code
- Deployment over HTTPS

---

### [ ] Step 5.5: Final Testing & QA
**Objective**: Full manual testing and QA.

**Task Instructions**:
1. Test all flows end-to-end:
   - User signup → browse → add cart → checkout → payment → confirmation
   - Admin login → product management → order processing
   - Mercado Libre shipping flow
   - Local pickup flow
2. Test on multiple browsers (Chrome, Firefox, Safari)
3. Test on mobile, tablet, desktop
4. Test with real Stripe test cards
5. Fix any bugs found
6. Document any known issues

**Deliverable**: QA report, all critical issues resolved

**Verification**:
- All flows work correctly
- Responsive on all devices
- No console errors
- Mobile-friendly

---

### [ ] Step 5.6: Deployment & Go-Live
**Objective**: Final deployment and monitoring setup.

**Task Instructions**:
1. Verify all env vars set in Vercel
2. Run `npm run build` locally → succeeds
3. Push final code to main branch
4. Vercel auto-deploys
5. Verify live URL works
6. Run E2E tests on production URL (smoke test)
7. Monitor first day for errors (Vercel logs, Sentry if configured)
8. Update DNS if using custom domain

**Deliverable**: Live production site

**Verification**:
- Production URL works
- All features functional
- No errors in logs
- Mobile responsive
- Fast load times
